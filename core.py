import math
from keyboard import wait as k_wait
from keyboard import read_key as k_read
from keyboard import on_press as k_on_press

class Screen:
    
    def __init__(self, row_len: int = 50):
        self.row_len = row_len
        self.scale = math.ceil(self.row_len / 25)
        self.line_count: int = 0

    def put(self, *values: str, row_len: int | None = None, preset: bool = False, **kwargs):
        if row_len is None:
            row_len = self.row_len
            scale = math.ceil(row_len / 25)
        else:
            scale = math.ceil(row_len / 25)
            row_len = 50
        if preset:
            self.line_count += values.count('\n')
            print(values, **kwargs)
            # need to adjust that shit
        else:
            for val in values:
                val = str(val)
                self.line_count += val.count('\n')
                self.line_count += len(val) // (scale * 25)
                counter = 0
                for char in val:
                    if counter % (scale * 25) == 0 and counter != 0:
                        print()
                    print(char, end='')
                    counter += 1
            self.line_count += 1
            print()
    
    def clear(self, extra: int = 0):
        line_count = self.line_count + extra
        print(f'\033[{line_count}A', end='')  # move cursor up N times (\033[<N>A)
        for i in range(self.line_count):
            print(' ' * self.row_len)
        print(f'\033[{line_count}A', end='')  # move cursor up N times (\033[<N>A)s
        self.line_count = 0

# screen = Screen()
# screen.put("ANSI escape sequences allow you to move the cursor around the screen at will. This is more useful for full screen user interfaces generated by shell scripts, but can also be used in prompts. The movement escape sequences are as follows something ....")
# screen.clear()

def clr_ln():
    print('\033[2K', end='\r')

class Menu():
    def Menu(screen: Screen, options: list[str]) -> str:
        selected: int = 0
        while True:
            for i in range(len(options)):
                if i == (selected % len(options)):
                    screen.put(f">{options[i]}")
                else:
                    screen.put(f" {options[i]}")
            key = k_read()
            if key == 'enter' or key == 'esc':
                break
            elif key == 'up':
                selected += 1
            elif key == 'down':
                selected -= 1
            else:
                pass
            screen.clear()

        return options[selected]
    
    def InfoMenu(screen: Screen, options: dict[str, str | int | float]) -> None:
        selected: int = 0
        keys = []
        for i in options.keys():
            keys.append(i)
        while True:
            for i in range(len(keys)):
                # modulus funny so it stays relative and cycles back in case you step back too far (like -5)
                if i == (selected % len(options)):
                    screen.put(f">{keys[i]}")
                else:
                    screen.put(f" {keys[i]}")
            key = k_read()
            if key == 'enter':
                screen.put(options[keys[selected % len(options)]], "\npress [SPACE] to continue")
                k_wait('space')
            elif key == 'esc':
                break
            elif key == 'up':
                selected += 1
            elif key == 'down':
                selected -= 1
            else:
                pass
            screen.clear()    

def startup(screen: Screen) -> None:
    from random import randint
    rand = randint(1, 10)
    if rand == 5:
        path = './VSwithcredits.txt'
    else:
        path = 'VSlogo.txt'
    with open(path, mode='r', encoding='utf8') as f:
        screen.put(f.read())
